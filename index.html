<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>i_am_dave — Mint (Base Sepolia)</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box}
  :root{--bg:#2B2B2B;--fg:#F3F3F3;--panel:#1f1f1f;--border:#3a3a3a;--accent:#7bd389}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:"JetBrains Mono",monospace}
  .wrap{max-width:560px;margin:0 auto;padding:max(24px, env(safe-area-inset-top)) 24px 24px}
  h1{font-size:18px;margin:0 0 6px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:16px}
  .btn{display:block;width:100%;background:#0c0c0c;border:1px solid var(--border);color:var(--fg);border-radius:10px;padding:12px 16px;font-size:16px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.small{width:auto;padding:8px 12px;font-size:12px}
  .input{width:100%;background:#151515;border:1px solid var(--border);color:var(--fg);border-radius:10px;padding:12px 14px;font-family:inherit;font-size:16px}
  .hint{font-size:12px;opacity:.85}
  .nft{width:100%;aspect-ratio:1/1;background:#2B2B2B;border:1px solid var(--border);border-radius:12px;display:grid;place-items:center;overflow:hidden}
  .nft img{max-width:90%;max-height:90%;display:block}
  .row{display:flex;align-items:center;gap:8px}
  .grow{flex:1}
  .right{text-align:right;margin-top:6px;opacity:.85;font-size:12px}
  .badge{display:inline-block;border:1px solid var(--border);border-radius:8px;padding:2px 6px;font-size:11px;opacity:.95}
  a.link{color:var(--fg);text-decoration:underline}
  .banner{background:#3a2b2b;border:1px solid #6b3a3a;color:#f3e6e6;padding:10px 12px;border-radius:8px;display:none;margin-bottom:8px}

  /* Accessible wallet chooser */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:1000}
  .modal{width:min(480px,92vw);background:#121212;border:1px solid var(--border);border-radius:14px;padding:16px}
  .modal h2{margin:0 0 8px;font-size:16px}
  .prov{display:flex;align-items:center;gap:10px;width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:#1a1a1a;color:var(--fg);cursor:pointer}
  .prov:hover{border-color:#555}
  .prov:focus{outline:2px solid var(--accent);outline-offset:2px}
  .prov img{width:22px;height:22px;border-radius:6px}
  .provname{font-size:14px}
  .provsub{margin-top:2px;font-size:11px;opacity:.8}
  .chooserGrid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:8px}
  .footrow{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
  .linklike{background:none;border:none;color:var(--accent);cursor:pointer;font-size:12px;text-decoration:underline;padding:0}
</style>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
/* =================== CONFIG =================== */
const CHAIN_ID_HEX = "0x14a34"; // 84532
const EXPLORER = "https://sepolia.basescan.org";
const DECLARATION_ADDR = "0xB0731E7ea189c169640Fd890E5dcE9811040D0eA";
const SBT_ADDR         = "0xe255130A9e2277640d3DfB045075a38d63a34D06";
const DECLARATION_DEPLOY_BLOCK = 30558001;

const BASE_SEPOLIA = {
  chainId: CHAIN_ID_HEX,
  chainName: "Base Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: ["https://sepolia.base.org"],
  blockExplorerUrls: [EXPLORER]
};

/* ABIs */
const DECLARATION_ABI = [
  "function hasSigned(address) view returns (bool)",
  "function signatureByAddress(address) view returns (string)",
  "function nameExists(string fullName) view returns (bool)",
  "function cosignDeclaration(string chosenName)",
  "event DeclarationSigned(address indexed signatory, string daveName, uint256 signatureNumber, uint256 blockNumber)"
];
const SBT_ABI = [
  "function claimWithSignee(uint256 signeeNumber)",
  "function tokenIdOf(address) view returns (uint256)",
  "function tokenURI(uint256) view returns (string)"
];

/* =================== STATE =================== */
const STATE = { DISCONNECTED:"DISCONNECTED", WRONG_NETWORK:"WRONG_NETWORK", READY:"READY", PENDING_SIGN:"PENDING_SIGN", PENDING_MINT:"PENDING_MINT", MINTED:"MINTED" };
let appState = STATE.DISCONNECTED;

let selectedProvider = null;
let discovered = [];
const LS_KEY = "dave_wallet_choice";

let provider, signer, user, onCorrectChain=false;
let autoConnectAfterChoose = false;
let hasSignedFlag = false;

/* connection mutex */
let connectLock = Promise.resolve();
let connectLocked = false;
function withConnectLock(fn){
  const run = async ()=>{ try{ connectLocked=true; return await fn(); } finally{ connectLocked=false; } };
  const p = connectLock.then(run, run);
  connectLock = p.catch(()=>{}); // keep chain alive
  return p;
}

/* =================== DOM HELPERS =================== */
const $ = id => document.getElementById(id);
const setStatus = msg => $("status").innerHTML = msg || "";
const setBanner = (show,msg)=>{ const b=$("banner"); if(show){b.style.display="block";b.textContent=msg}else{b.style.display="none";b.textContent=""} };

function setPrimaryLabelForReady(btn){ btn.textContent = hasSignedFlag ? "MINT SBT" : "SIGN DECLARATION"; }
function setButton(state){
  appState=state; const btn=$("primary");
  if(state===STATE.DISCONNECTED){btn.textContent="CONNECT WALLET";btn.disabled=false;btn.onclick=onPrimaryClick;return;}
  if(state===STATE.WRONG_NETWORK){
    btn.textContent="SWITCH TO BASE SEPOLIA";
    btn.disabled=false;
    btn.onclick=async()=>{
      const ok=await attemptSwitchNetwork();
      if(!ok) setStatus("Open your wallet and switch/add Base Sepolia (chainId 84532).");
    };
    return;
  }
  if(state===STATE.READY){ setPrimaryLabelForReady(btn); btn.disabled=false;btn.onclick=onPrimaryClick;return; }
  if(state===STATE.PENDING_SIGN){btn.textContent="WORKING…";btn.disabled=true;btn.onclick=null;return;}
  if(state===STATE.PENDING_MINT){btn.textContent="MINTING…";btn.disabled=true;btn.onclick=null;return;}
  if(state===STATE.MINTED){btn.textContent="MINTED";btn.disabled=true;btn.onclick=null;return;}
}

function showPreviewTile(){ $("tile").innerHTML = `<div id="previewText" style="font-size:24px;color:#F3F3F3;">i_am_(yourName)_dave</div>`; }
function showNftTile(src){ $("tile").innerHTML = `<img id="nftImg" alt="Your NFT" src="${src}">`; }

function updatePreview(){
  const v=$("name").value.trim();
  $("count").textContent=`${v.length}/14`;
  if(appState!==STATE.MINTED){
    $("previewText").textContent = v ? `i_am_${v}_dave` : "i_am_(yourName)_dave";
  }
}
function normalizeInput(e){
  const before=e.target.value;
  const after=before.toLowerCase().replace(/[^a-z0-9-]/g,"").slice(0,14);
  if(before!==after) e.target.value=after;
  updatePreview();
}

/* =================== ERROR UTIL =================== */
function decodeErrorData(data){
  try{
    const hex = typeof data === "string" ? data : data?.data || "";
    if (typeof hex === "string" && hex.startsWith("0x08c379a0")) {
      const reason = ethers.utils.defaultAbiCoder.decode(["string"], "0x"+hex.slice(10));
      return reason?.[0];
    }
  }catch{}
  return null;
}
function rpcMessage(err){
  if (err?.code === 4001) return "You canceled in your wallet.";
  const msg = err?.message || err?.error?.message || err?.data?.message || "";
  if (/insufficient funds/i.test(msg)) return "You need test ETH for gas on Base Sepolia.";
  const d = err?.data || err?.error?.data || err?.error || {};
  const reason = decodeErrorData(d?.originalError?.data || d?.data || d);
  return reason || d?.message || msg || "Unknown RPC error";
}

/* =================== EIP-6963 DISCOVERY =================== */
function startDiscovery(){
  discovered = [];
  window.addEventListener("eip6963:announceProvider", (event) => {
    const d = event.detail;
    if (!discovered.some(x => (x.info?.uuid && x.info.uuid===d.info.uuid) || (x.info?.rdns && x.info.rdns===d.info.rdns))) {
      discovered.push(d);
    }
  });
  try { window.dispatchEvent(new Event("eip6963:requestProvider")); } catch {}
}
function buildFallbackList(){
  const arr = [];
  const eth = window.ethereum;
  if (!eth) return arr;
  const providers = Array.isArray(eth.providers) ? eth.providers : [eth].filter(Boolean);
  providers.forEach(p => {
    const name =
      p.isMetaMask ? "MetaMask" :
      p.isCoinbaseWallet ? "Coinbase Wallet" :
      p.isBraveWallet ? "Brave Wallet" :
      p.isFrame ? "Frame" :
      p.isRabby ? "Rabby" : "Injected Wallet";
    const id = p.isMetaMask ? "metamask" :
              p.isCoinbaseWallet ? "coinbase" :
              p.isBraveWallet ? "brave" :
              p.isFrame ? "frame" :
              p.isRabby ? "rabby" : "injected";
    arr.push({ provider:p, info:{ name, rdns:id, uuid:id }});
  });
  return arr;
}

/* ====== Modal (accessible) ====== */
let lastFocusedEl = null;
function getFocusableWithin(node){
  return node.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
}
function openChooser(autoconnect=false){
  autoConnectAfterChoose = autoconnect;
  lastFocusedEl = document.activeElement;
  let list = discovered.length ? discovered : buildFallbackList();
  const grid = $("chooserList");
  grid.innerHTML = "";
  if (!list.length){
    grid.innerHTML = `<div class="hint">No browser wallet detected. Install <a class="link" href="https://metamask.io" target="_blank" rel="noopener">MetaMask</a> or enable your extension, then reopen the chooser.</div>`;
  } else {
    const priority = ["metamask","coinbase","rabby","brave","frame"];
    list.sort((a,b)=>{
      const ra = priority.indexOf(a.info?.rdns); const rb = priority.indexOf(b.info?.rdns);
      return (ra===-1?999:ra) - (rb===-1?999:rb);
    });
    list.forEach((d) => {
      const item = document.createElement("button");
      item.className = "prov";
      item.setAttribute("aria-label", `Connect with ${d.info?.name || "wallet"}`);
      const icon = d.info?.icon || "";
      const name = d.info?.name || "Wallet";
      const sub  = d.info?.rdns || "";
      item.innerHTML = `${icon?`<img src="${icon}" alt="">`:``}<div><div class="provname">${name}</div><div class="provsub">${sub}</div></div>`;
      // IMPORTANT: request accounts INSIDE this click handler (user gesture)
      item.onclick = async () => {
        await useProviderAndRequestAccounts(d, true);
      };
      grid.appendChild(item);
    });
  }
  $("overlay").style.display="flex";
  const focusables = getFocusableWithin($("modal"));
  focusables[0]?.focus();
  $("overlay").addEventListener("keydown", trapFocus);
}
function closeChooser(){
  $("overlay").style.display="none";
  $("overlay").removeEventListener("keydown", trapFocus);
  lastFocusedEl?.focus();
}
function trapFocus(e){
  if (e.key === "Escape") { e.preventDefault(); closeChooser(); return; }
  if (e.key !== "Tab") return;
  const focusables = Array.from(getFocusableWithin($("modal")));
  if (!focusables.length) return;
  const first = focusables[0];
  const last = focusables[focusables.length-1];
  if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
  else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
}

/* ====== Provider selection + gesture-phase account request ====== */
async function useProviderAndRequestAccounts(detail, remember){
  // lock to prevent chooser double taps
  await withConnectLock(async ()=>{
    selectedProvider = detail.provider;
    if (remember){
      const key = detail.info?.uuid || detail.info?.rdns || "injected";
      localStorage.setItem(LS_KEY, key);
    }
    $("chosenLabel").textContent = detail.info?.name || "Wallet";
    attachWalletListeners(selectedProvider);

    try{
      // Request accounts DURING the user gesture
      await selectedProvider.request({ method:"eth_requestAccounts" });
    }catch(err){
      setStatus(rpcMessage(err));
      return; // do not proceed
    } finally {
      closeChooser();
    }

    // Now finish full connect flow but SKIP another request
    await connect({ skipAccountRequest:true });
  });
}

/* =================== CHAIN / RPC HELPERS =================== */
async function readChainId(p){ const id=await p.request({method:"eth_chainId"}); return (id||"").toLowerCase(); }
async function attemptSwitchNetwork(){
  if(!selectedProvider) return false;
  try{
    await selectedProvider.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CHAIN_ID_HEX }] });
    return true;
  }catch(err){
    if(err?.code===4902 || err?.data?.originalError?.code===4902){
      try{
        await selectedProvider.request({ method:"wallet_addEthereumChain", params:[BASE_SEPOLIA] });
        return true;
      }catch{}
    }
  }
  return false;
}
async function preflightContracts(){
  const codeDecl = await provider.getCode(DECLARATION_ADDR);
  if(!codeDecl || codeDecl==="0x") throw new Error("No contract code at Declaration address on this network.");
  const codeSbt = await provider.getCode(SBT_ADDR);
  if(!codeSbt || codeSbt==="0x") throw new Error("No contract code at SBT address on this network.");
}

/* =================== CONTRACT HELPERS =================== */
async function getSigneeNumberViaLogs(addr){
  const decl = new ethers.Contract(DECLARATION_ADDR, DECLARATION_ABI, provider);
  const filter = decl.filters.DeclarationSigned(addr);
  const latest = await provider.getBlockNumber();
  const WINDOW = 30000;
  let from = Math.max(DECLARATION_DEPLOY_BLOCK, latest - WINDOW);
  while (from >= DECLARATION_DEPLOY_BLOCK){
    const to = from + WINDOW;
    const logs = await decl.queryFilter(filter, from, to).catch(()=>[]);
    if (logs && logs.length){
      const last = logs[logs.length-1];
      return last.args.signatureNumber.toNumber();
    }
    from -= WINDOW;
  }
  throw new Error("No DeclarationSigned event found for this address");
}
async function getSigneeNumberWithRetry(addr, tries=6, delayMs=1200){
  let lastErr;
  for(let i=0;i<tries;i++){
    try{ return await getSigneeNumberViaLogs(addr); }
    catch(e){ lastErr=e; await new Promise(r=>setTimeout(r,delayMs)); }
  }
  throw lastErr;
}
async function getMintedTokenIdFromReceipt(rc){
  try{
    const erc721=new ethers.utils.Interface(["event Transfer(address indexed from,address indexed to,uint256 indexed tokenId)"]);
    const topic=erc721.getEventTopic("Transfer");
    const logs=rc.logs.filter(l => l.address.toLowerCase()===SBT_ADDR.toLowerCase() && l.topics[0]===topic);
    for(const l of logs){
      if(l.topics[2].toLowerCase()===ethers.utils.hexZeroPad(user,32).toLowerCase()){
        const parsed=erc721.parseLog(l);
        return parsed.args.tokenId;
      }
    }
  }catch{}
  return null;
}
async function pollTokenIdOf(addr, tries=8, delayMs=1200){
  const sbt=new ethers.Contract(SBT_ADDR,SBT_ABI,signer);
  for(let i=0;i<tries;i++){
    try{
      const tid=await sbt.tokenIdOf(addr);
      if(tid && !ethers.BigNumber.from(tid).isZero()) return tid;
    }catch{}
    await new Promise(r=>setTimeout(r,delayMs));
  }
  throw new Error("Token not visible yet; switch back to the tab for a moment and it should appear.");
}
async function parseTokenJSON(uri){
  if (uri?.startsWith("data:application/json")) {
    const base64 = uri.split(",")[1] || "";
    if (base64.length > 500_000 && "requestIdleCallback" in window) {
      return await new Promise(res=>requestIdleCallback(()=>res(JSON.parse(atob(base64)))));
    }
    return JSON.parse(atob(base64));
  } else {
    const gw = uri?.startsWith("ipfs://") ? uri.replace("ipfs://","https://ipfs.io/ipfs/") : uri;
    const res = await fetch(gw, { cache:"no-store" });
    return await res.json();
  }
}
async function fetchTokenJSON(sbt, tokenId, tries=12, delayMs=1200){
  let lastErr;
  for(let i=0;i<tries;i++){
    try{
      const uri = await sbt.tokenURI(tokenId);
      return await parseTokenJSON(uri);
    } catch(e) { lastErr=e; await new Promise(r=>setTimeout(r,delayMs)); }
  }
  throw lastErr || new Error("tokenURI not available yet");
}

/* =================== CONNECT / FLOW =================== */
async function connect(opts={skipAccountRequest:false}){
  // ensure serialized connects
  return withConnectLock(async ()=>{
    setButton(STATE.PENDING_SIGN);

    // resolve saved provider on first manual connect only
    if (!selectedProvider){
      const savedKey = localStorage.getItem(LS_KEY);
      let list = discovered.length ? discovered : buildFallbackList();
      const found = list.find(d => d.info?.uuid===savedKey || d.info?.rdns===savedKey);
      if (found) {
        selectedProvider = found.provider;
        attachWalletListeners(selectedProvider);
        $("chosenLabel").textContent = found.info?.name || "Wallet";
      } else {
        // user hasn’t picked yet
        openChooser(true);
        return;
      }
    }

    // If this wasn’t started by a user gesture request, do it now (single attempt)
    if (!opts.skipAccountRequest){
      try{
        await selectedProvider.request({method:"eth_requestAccounts"});
      }catch(err){
        setStatus(rpcMessage(err));
        setButton(STATE.DISCONNECTED);
        return;
      }
    }

    provider = new ethers.providers.Web3Provider(selectedProvider, "any");
    signer   = provider.getSigner();
    user     = await signer.getAddress();

    let chain = await readChainId(selectedProvider);
    onCorrectChain = chain === CHAIN_ID_HEX;
    if(!onCorrectChain){
      setBanner(true,"Switch your wallet to Base Sepolia (84532). Attempting to switch now.");
      await attemptSwitchNetwork().catch(()=>{});
      chain = await readChainId(selectedProvider).catch(()=>chain);
      onCorrectChain = chain === CHAIN_ID_HEX;
    }
    setStatus(`Connected: ${user.slice(0,6)}…${user.slice(-4)} • Chain: ${chain}`);
    if(!onCorrectChain){
      setBanner(true,"Switch your wallet to Base Sepolia (84532). This page will update automatically once you switch.");
      setButton(STATE.WRONG_NETWORK);
      return;
    }
    setBanner(false);

    try{ await preflightContracts(); }
    catch(preErr){ setStatus(preErr.message); setButton(STATE.DISCONNECTED); return; }

    const declaration=new ethers.Contract(DECLARATION_ADDR,DECLARATION_ABI,signer);
    const sbt=new ethers.Contract(SBT_ADDR,SBT_ABI,signer);

    // Already minted?
    try{
      const tid=await sbt.tokenIdOf(user);
      if(tid && !ethers.BigNumber.from(tid).isZero()){
        const data=await fetchTokenJSON(sbt, tid);
        showNftTile(data.image);
        $("finalName").textContent=data.name||"";
        $("links").style.display="flex";
        $("name").disabled=true;
        $("signedBadge").style.display="inline-block";
        hasSignedFlag = true;
        setButton(STATE.MINTED);
        return;
      }
    }catch{}

    // Already signed?
    hasSignedFlag = false;
    try {
      const signed = await declaration.hasSigned(user);
      if (signed) {
        const full = await declaration.signatureByAddress(user);
        const m = full.match(/^i_am_(.*)_dave$/);
        if (m && m[1]) { $("name").value = m[1]; $("name").disabled = true; }
        $("signedBadge").style.display = "inline-block";
        hasSignedFlag = true;
      } else {
        $("name").disabled = false;
        $("signedBadge").style.display = "none";
      }
    } catch {
      $("name").disabled = false;
      $("signedBadge").style.display = "none";
    }

    showPreviewTile(); updatePreview();
    setButton(STATE.READY);
  });
}

async function onPrimaryClick(){
  if(appState===STATE.DISCONNECTED){
    if (!selectedProvider) { openChooser(true); return; }
    return connect();
  }
  if(appState===STATE.WRONG_NETWORK) return;
  if(appState!==STATE.READY) return;

  try{
    const declaration=new ethers.Contract(DECLARATION_ADDR,DECLARATION_ABI,signer);
    const sbt=new ethers.Contract(SBT_ADDR,SBT_ABI,signer);

    const chosen=$("name").value.trim();
    if(!/^[a-z0-9-]{1,14}$/.test(chosen)){ setStatus("Name must be 1–14 chars, lowercase a–z, 0–9 or '-'"); return; }

    if(!hasSignedFlag){
      setButton(STATE.PENDING_SIGN);
      setStatus("Checking name and preparing to sign…");

      const full = `i_am_${chosen}_dave`;
      try{
        const exists = await declaration.nameExists(full);
        if (exists) { setStatus("That name is already taken. Try another."); setButton(STATE.READY); return; }
      }catch{}

      try{ await declaration.callStatic.cosignDeclaration(chosen); }
      catch(e){ throw new Error("Declaration revert: " + rpcMessage(e)); }

      setStatus("Signing the Declaration…");
      const tx = await declaration.cosignDeclaration(chosen);
      const rc = await tx.wait();
      setStatus(`Signed. <a class="link" target="_blank" rel="noopener" href="${EXPLORER}/tx/${rc.transactionHash}">View on BaseScan</a>`);
      $("name").disabled = true;
      $("signedBadge").style.display = "inline-block";
      hasSignedFlag = true;
      setButton(STATE.READY);
      return;
    }

    setButton(STATE.PENDING_MINT);
    setStatus("Minting your soulbound NFT…");
    const signeeNumber = await getSigneeNumberWithRetry(user, 6, 1200);

    try{ await sbt.callStatic.claimWithSignee(signeeNumber); }
    catch(e){ throw new Error("Mint revert: " + rpcMessage(e)); }

    const tx2 = await sbt.claimWithSignee(signeeNumber, { gasLimit: 300000 });
    const rc2 = await tx2.wait();

    let tokenId = await getMintedTokenIdFromReceipt(rc2);
    if(!tokenId) tokenId = await pollTokenIdOf(user);

    const data = await fetchTokenJSON(sbt, tokenId, 12, 1200);

    showNftTile(data.image);
    $("finalName").textContent = data.name || "";
    $("links").style.display = "flex";
    $("opensea").href = `https://testnets.opensea.io/assets/base-sepolia/${SBT_ADDR}/${tokenId}`;

    setStatus(`Minted. <a class="link" target="_blank" rel="noopener" href="${EXPLORER}/tx/${rc2.transactionHash}">View on BaseScan</a>`);
    setButton(STATE.MINTED);

  }catch(err){
    console.error(err);
    setStatus(rpcMessage(err));
    setButton(STATE.READY);
  }
}

/* =================== LISTENERS =================== */
function attachWalletListeners(p){
  if(!p) return;
  p.removeAllListeners?.();
  p.on?.("accountsChanged",()=>{
    $("status").innerHTML = "Account changed. Reconnect.";
    selectedProvider && console.info("accountsChanged");
    user = null; provider = null; signer = null;
    hasSignedFlag = false;
    $("name").disabled=false; $("signedBadge").style.display="none";
    showPreviewTile(); updatePreview(); $("links").style.display="none";
    setButton(STATE.DISCONNECTED);
  });
  p.on?.("chainChanged", async (cid)=>{
    const ok=(cid||"").toLowerCase()===CHAIN_ID_HEX;
    if(ok){
      setBanner(false);
      await connect({ skipAccountRequest:true });
    } else {
      setBanner(true,"Switch your wallet to Base Sepolia (84532). This page will update automatically once you switch.");
      setButton(STATE.WRONG_NETWORK);
    }
  });
  p.on?.("disconnect",(err)=>{
    console.warn("Provider disconnected", err);
    user = null; provider = null; signer = null;
    hasSignedFlag = false;
    setBanner(true,"Wallet disconnected. Reconnect to continue.");
    setButton(STATE.DISCONNECTED);
  });
}
window.addEventListener("visibilitychange", async ()=>{
  if(document.visibilityState==="visible" && selectedProvider && user && !connectLocked){
    try{
      const chain = await readChainId(selectedProvider);
      const ok = chain === CHAIN_ID_HEX;
      if(ok && appState===STATE.WRONG_NETWORK){ setBanner(false); await connect({ skipAccountRequest:true }); }
      if(!ok && appState!==STATE.WRONG_NETWORK){ setBanner(true,"Switch your wallet to Base Sepolia (84532)."); setButton(STATE.WRONG_NETWORK); }
    }catch{}
  }
});
document.addEventListener("keydown",(e)=>{
  if ($("overlay").style.display==="flex" && e.key==="Escape") closeChooser();
});

/* =================== BOOT =================== */
async function trySilentReconnect(){
  const savedKey = localStorage.getItem(LS_KEY);
  if (!savedKey) return;
  // DO NOT call eth_requestAccounts here (no user gesture)
  let list = discovered.length ? discovered : buildFallbackList();
  let found = list.find(d => d.info?.uuid===savedKey || d.info?.rdns===savedKey);
  if (!found){
    await new Promise(r=>setTimeout(r, 300));
    list = discovered.length ? discovered : buildFallbackList();
    found = list.find(d => d.info?.uuid===savedKey || d.info?.rdns===savedKey);
  }
  if (!found) return;
  selectedProvider = found.provider;
  attachWalletListeners(selectedProvider);
  try{
    const accs = await selectedProvider.request({ method:"eth_accounts" });
    if (Array.isArray(accs) && accs.length){
      $("chosenLabel").textContent = found.info?.name || "Wallet";
      // proceed without another accounts request
      await connect({ skipAccountRequest:true });
    }
  }catch{}
}

window.addEventListener("DOMContentLoaded",()=>{
  $("primary").onclick = onPrimaryClick;
  $("changeWallet").onclick = ()=>{
    localStorage.removeItem(LS_KEY);
    selectedProvider=null;
    $("chosenLabel").textContent="—";
    openChooser(true);
  };
  $("name").addEventListener("input",normalizeInput);
  showPreviewTile(); updatePreview();
  startDiscovery();
  trySilentReconnect();
});
</script>
</head>
<body>
  <div class="wrap">
    <h1>i_am_dave — The Banksy Stays on the Wall (Base Sepolia)</h1>

    <div class="card">
      <div id="banner" class="banner"></div>

      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px;">
        <button class="btn" id="primary">CONNECT WALLET</button>
      </div>

      <div class="row" style="justify-content:space-between;margin-top:4px;">
        <div class="hint">Wallet: <span id="chosenLabel">—</span></div>
        <button id="changeWallet" class="linklike">Change wallet</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="name" class="input grow" maxlength="14" placeholder="yourname" autocomplete="off" />
      </div>
      <div class="row" style="justify-content:space-between;margin-top:6px;">
        <div class="hint"><span id="signedBadge" class="badge" style="display:none;">Signed ✓</span></div>
        <div class="right"><span id="count">0/14</span></div>
      </div>

      <div id="tile" class="nft" style="margin-top:12px;">
        <div id="previewText" style="font-size:24px;color:#F3F3F3;">i_am_(yourName)_dave</div>
      </div>

      <div id="links" class="hint" style="display:none;margin-top:10px;">
        <a id="opensea" class="link" target="_blank" rel="noopener">OpenSea (may not load on testnet)</a>
      </div>

      <div id="finalName" class="hint" style="margin-top:6px;"></div>
      <div id="status" class="hint" style="margin-top:10px;"></div>
    </div>

    <div class="hint">Declaration: 0xB0731E7ea189c169640Fd890E5dcE9811040D0eA • SBT: 0xe255130A9e2277640d3DfB045075a38d63a34D06 • Base Sepolia</div>
  </div>

  <!-- Wallet chooser modal; accessible -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-labelledby="chooserTitle">
    <div class="modal" id="modal">
      <h2 id="chooserTitle">Select a wallet</h2>
      <div class="chooserGrid" id="chooserList"></div>
      <div class="footrow">
        <span class="hint">Your choice is remembered for this site.</span>
        <button class="btn small" onclick="closeChooser()">Close</button>
      </div>
    </div>
  </div>
</body>
</html>
